""""""""""""""""
" NEOBUNDLE:
""""""""""""""""
	" Disable vi-compatibility
	set nocompatible

	if has ('vim_starting')
		set runtimepath+=~/.vim/bundle/neobundle.vim/
	endif

	call neobundle#begin(expand('~/.vim/bundle/'))

	" PLUGINS
		" Let NeoBundle manage NeoBundle
		NeoBundleFetch 'Shougo/neobundle.vim'

		NeoBundle 'Shougo/vimproc.vim', {
		\ 'build' : {
		\     'windows' : 'tools\\update-dll-mingw',
		\     'cygwin' : 'make -f make_cygwin.mak',
		\     'mac' : 'make -f make_mac.mak',
		\     'unix' : 'make -f make_unix.mak',
		\    },
		\ }

		" enhancements
			" let `.` repeat things like plugin mappings
			NeoBundle 'tpope/vim-repeat'
			" <tab>-complete in insert mode
			NeoBundle 'ervandew/supertab'
			" <tab>-complete in the search prompt
			NeoBundle 'SearchComplete'

		" navigation
			NeoBundle 'Lokaltog/vim-easymotion'

		" languages
			NeoBundle 'Chiel92/vim-autoformat'
			NeoBundle 'mustache/vim-mustache-handlebars'

		" unite
			NeoBundle 'Shougo/unite.vim'
			NeoBundle 'Shougo/neomru.vim'
			NeoBundle 'Shougo/unite-outline'
			NeoBundle 'thinca/vim-unite-history'

		" utils
			" sensible default settings
			NeoBundle 'tpope/vim-sensible'
			" auto-detuct indent settings
			NeoBundle 'tpope/vim-sleuth'
			NeoBundle 'tpope/vim-surround'
			" comment mappings
			NeoBundle 'tpope/vim-commentary'
			" settings toggles and symmetrical before/after mappings
			NeoBundle 'tpope/vim-unimpaired'
			NeoBundle 'scrooloose/nerdtree'
			NeoBundle 'jistr/vim-nerdtree-tabs'
			" visualized undo tree
			NeoBundle 'sjl/gundo.vim'
			" better multiple-cursor functionality
			NeoBundle 'terryma/vim-multiple-cursors'
			" diff two selections
			NeoBundle 'AndrewRadev/linediff.vim'
			NeoBundle 'scrooloose/syntastic'
			NeoBundle 'thinca/vim-qfreplace'
			" show trailing whitespace, and provide a command to clean it
			NeoBundle 'ntpeters/vim-better-whitespace'

		" UI
			NeoBundle 'bling/vim-airline'
			NeoBundle 'nanotech/jellybeans.vim'
			NeoBundle 'tomasr/molokai'
			NeoBundle 'xoria256.vim'
			NeoBundle 'altercation/vim-colors-solarized'
			NeoBundle 'chriskempson/base16-vim'

		" integration
			" git
			NeoBundle 'tpope/vim-fugitive'
			" ag, the silver searcher
			NeoBundle 'rking/ag.vim'
			" LaTeX
			NeoBundle 'LaTeX-Box-Team/LaTeX-Box'

		" external
			NeoBundle 'christoomey/vim-tmux-navigator'
			NeoBundle 'edkolev/tmuxline.vim'
			NeoBundle 'edkolev/promptline.vim'
	" /PLUGINS

	call neobundle#end()

	" Prompt to install any newly added bundles
	NeoBundleCheck


""""""""""""""""
" SETTINGS:
""""""""""""""""
	" take me to your <leader>
	let mapleader=","
	let maplocalleader="-"
	" line numbers
	set number
	set smartcase
	set ignorecase
	set hlsearch
	set cursorline

	" tabs!
	set tabstop=4
	set shiftwidth=4

	" turn off auto-textwrap (vim-sensible turns it on)
	set textwidth=0

	" spell checking (toggled with `cos`)
	" set spell

	" simple mouse support
	set mouse=a

	" paste without comments messing everything up
	set pastetoggle=<f4>

	" Let arrow keys pass \n
	set whichwrap=b,s,<,>,[,]

	" folding
	set foldmethod=indent
	set foldlevelstart=128
	set foldcolumn=2
	augroup rcFolds
		" support both indent and manual folding
		au BufReadPre * setlocal foldmethod=indent
		au BufWinEnter * if &fdm == 'indent' | setlocal foldmethod=manual | endif
	augroup END

	" more natural splits
	set splitbelow
	set splitright

	" ignore in searches
	set wildignore+=node_modules/**


""""""""""""""""
" THEME:
""""""""""""""""
	syntax enable
	set t_Co=256
	set background=dark
	" set background=light

	" colorscheme molokai
	" colorscheme jellybeans

	colorscheme xoria256
	let g:rehash256 = 1

	" let g:solarized_termtrans = 1
	" " let g:solarized_termcolors=256
	" colorscheme solarized
	call togglebg#map("<f5>")


""""""""""""""""
" MAPPINGS:
""""""""""""""""
	" fix Y
	map Y y$

	" shift is for sucks? (avoids :W style typos)
	map ; :

	" L-s => save [:update]
	map <leader>s :update<cr>
	" L-S => force save [:write]
	map <leader>S :write<cr>

	" L-w => quit [:quit]
	map <leader>w :quit<cr>
	" L-W => force quit [:quit!]
	map <leader>W :quit!<cr>

	" L-x => save and quit [:wq]
	map <leader>x :wq<cr>

	" U => redo [:redo]
	map U :redo<cr>
	" L-u => undo line
	noremap <leader>u U<cr>

	" L-r => reload file [:edit]
	map <leader>r :edit<cr>

	" insert/append
		" tab
		noremap <leader>it i<tab>
		noremap <leader>i<tab> i<tab>
		noremap <leader>at a<tab>
		noremap <leader>a<tab> a<tab>

	" tabs and panes
		" prefix
		map [tabs] <nop>
		map [tabs][alt] <nop>
		map <leader>t [tabs]
		map <leader>T [tabs][alt]

		" new
		map [tabs] :tabnew<cr>
		map [tabs]t :tabnew<cr>
		" duplicate
		map [tabs]d :tabnew %<cr>
		" close
		map [tabs]w :tabclose<cr>
		map [tabs]W :tabclose!<cr>
		" close others
		map [tabs]o :tabonly<cr>
		map [tabs]O :tabonly!<cr>
		" first
		map [tabs]f :tabfirst<cr>
		" last
		map [tabs]l :tablast<cr>
		" next
		map [tabs]n :tabnext<cr>
		" previous
		map [tabs]p :tabprevious<cr>
		" move to last
		map [tabs][alt] :tabmove<cr>

	" folding
		nnoremap <silent> <space> @=(foldlevel('.')?'za':"\<space>")<cr>
		vnoremap <space> zf

		nmap z` :set foldlevel=0<cr>
		nmap z1 :set foldlevel=1<cr>
		nmap z2 :set foldlevel=2<cr>
		nmap z3 :set foldlevel=3<cr>
		nmap z4 :set foldlevel=4<cr>
		nmap z5 :set foldlevel=5<cr>
		nmap z6 :set foldlevel=6<cr>
		nmap z7 :set foldlevel=7<cr>
		nmap z8 :set foldlevel=8<cr>
		nmap z9 :set foldlevel=9<cr>
		nmap z0 :set foldlevel=128<cr>
		nmap zz :call ToggleFold()<cr>

		let b:foldlevel=&l:foldlevel
		function! ToggleFold()
			if &l:foldmethod == 'indent'
				set foldmethod=manual
			else
				set foldmethod=indent
			endif
			" if &l:foldenable
			" 	let b:foldlevel=&l:foldlevel
			" 	set nofoldenable
			" else
			" 	set foldenable
			" 	set foldlevel = b:foldlevel
			" endif
		endfunction

	" searching
		" clear highlighted search
		nmap <leader>/ :nohlsearch<cr>
		" search for selected word
		vmap <leader>/ y/<c-r>"<cr>

	" visual shifting (does not exit Visual mode)
	map < <gv
	map > >gv

	" use Q for formatting, not Ex mode
	map Q gq
	map Q gq

	" set a break in undo, so CTRL-U in insert mode is less destructive
	map <c-u> <c-g>u<c-u>

	" switch to alternate file
	map <leader><leader> <c-^>

	" easier system clipboard
	map <leader>y "+y
	map <leader>Y "+Y
	map <leader>p "+p
	map <leader>P "+P

	" grade-A prankster
	noremap <up> <left>
	noremap <down> <up>
	noremap <left> <right>
	noremap <right> <down>

	" CONSOLE
		" :W => write with sudo
		command! W :execute ':silent w !sudo tee % > /dev/null' | :edit!

		" reload vimrc config
		cmap reload source ~/.vim/vimrc

		" change Working Directory to that of the current file
		cmap cwd lcd %:p:h

		" diff unsaved changes
		if !exists(":DiffChanges")
			command DiffChanges vert new | set bt=nofile | r ++edit # | 0d_ | diffthis | wincmd p | diffthis
		endif


""""""""""""""""
" MISC:
""""""""""""""""
	if has("autocmd")
		filetype plugin on

		augroup rcMain
			au!

			" Reload vimrc when edited (using :reload, defined above)
			autocmd! BufWritePost vimrc source ~/.vim/vimrc

			" Preserve cursor position
			autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif

			" Remove trailing whitespaces and \^M chars
			" NOTE: removing in favor of vim-better-whitespace, for more control/knowledge
			" autocmd FileType c,cpp,java,php,js,python,twig,xml,yml autocmd BufWritePre <buffer> :call setline(1, map(getline(1, '$'), 'substitute(v:val, "\\s\\+$", "", "")'))

			" turn on spell check in certain files, and move cursor to beginning of gitcommits
			autocmd BufRead,BufNewFile *.md setlocal spell | set complete+=kspell
			autocmd FileType gitcommit setlocal spell | set complete+=kspell | call cursor(1, 1)

			" syntax highlighting
			autocmd BufNewFile,BufReadPost *.md set filetype=markdown

			" default to shell script syntax
			autocmd BufNewFile,BufRead * if &syntax == '' | set syntax=sh | endif
			autocmd BufNewFile,BufRead * if &filetype == '' | set filetype=sh | endif
		augroup END
	endif


""""""""""""""""
" PLUGINS:
""""""""""""""""
	" Unite:
		let g:unite_source_history_yank_enable = 1

		" ack >> grep
		if executable('ack')
			let g:unite_source_grep_command = 'ack'
			let g:unite_source_grep_default_opts = '-i --no-heading --no-color -k -H'
			let g:unite_source_grep_recursive_opt = ''
		endif

		" ag > ack
		if executable('ag')
			let g:unite_source_grep_command = 'ag'
			let g:unite_source_grep_default_opts = '--nogroup --nocolor --column --hidden'
			let g:unite_source_grep_recursive_opt = ''
			let g:unite_source_rec_async_command = 'ag --follow --nocolor --nogroup --hidden -g ""'
		endif

		call unite#custom#profile('default', 'context', {
		\   'winheight': 24,
		\ })

		call unite#filters#matcher_default#use(['matcher_fuzzy'])
		call unite#custom#source('buffer,file,file_rec,file_rec/async', 'sorters', ['sorter_length', 'sorter_rank'])
		call unite#custom#source('file_rec/async', 'ignore_globs', split(&wildignore, ','))
		call unite#custom#source('file_rec/async', 'converters', [])
		call unite#custom#source('file_rec/async', 'max_candidates', 24)
		" prettier output
		call unite#custom#source('buffer', 'converters', ['converter_file_directory'])

		" in-buffer settings
		function! s:unite_settings()
			let b:SuperTabDisabled = 1

			" vertical selecting (`j` and `k` is default in normal mode)
			imap <buffer> <c-j> <plug>(unite_select_next_line)
			imap <buffer> <c-k> <plug>(unite_select_previous_line)

			" action menu (`a` is default in normal mode)
			imap <buffer> <c-a> <plug>(unite_choose_action)
			" TODO: get something like this working: (may depend on https://github.com/Shougo/unite.vim/issues/280)
			vmap <buffer> a <plug>(unite_choose_action)

			" open in vertical split
			nmap <buffer><expr> - unite#do_action('split')
			imap <buffer><expr> <c--> unite#do_action('split')
			" open in horizontal split
			nmap <buffer><expr> s unite#do_action('vsplit')
			imap <buffer><expr> <c-s> unite#do_action('vsplit')
			" open in new tab (`t` is default in normal mode)
			imap <buffer><expr> <c-t> unite#do_action('tabopen')

			" toggle auto preview
			nmap <buffer> <c-p> <plug>(unite_toggle_auto_preview)

			" exit
			nmap <buffer> <esc> <plug>(unite_exit)

			let unite = unite#get_current_unite()
			if unite.profile_name ==# 'search'
				nmap <silent><buffer><expr> r     unite#do_action('replace')
			else
				nmap <silent><buffer><expr> r     unite#do_action('rename')
			endif
		endfunction
		autocmd FileType unite call s:unite_settings()

		" prefix
		map [unite] <nop>
		map <leader><space> [unite]
		map [unite][alt] <nop>
		map [unite]<space> [unite][alt]

		" open files
			" flat
			nmap [unite]f :Unite              -buffer-name=files -start-insert file directory file/new directory/new<cr>
			nmap [unite]F :UniteWithBufferDir -buffer-name=files -start-insert file directory file/new directory/new<cr>
			nmap [unite][alt]f :Unite              -buffer-name=files -start-insert -auto-preview file directory file/new directory/new<cr>
			nmap [unite][alt]F :UniteWithBufferDir -buffer-name=files -start-insert -auto-preview file directory file/new directory/new<cr>

			" recursive
			nmap [unite]p :Unite              -buffer-name=files -start-insert file_rec/async:!<cr>
			nmap [unite]P :UniteWithBufferDir -buffer-name=files -start-insert file_rec/async:!<cr>
			nmap [unite][alt]p :Unite              -buffer-name=files -start-insert -auto-preview file_rec/async:!<cr>
			nmap [unite][alt]P :UniteWithBufferDir -buffer-name=files -start-insert -auto-preview file_rec/async:!<cr>

		" search files
			nmap [unite]g :Unite              grep:.<cr>
			nmap [unite]G :UniteWithBufferDir grep:.<cr>
			nmap [unite][alt]g :Unite              -auto-preview grep:.<cr>
			nmap [unite][alt]G :UniteWithBufferDir -auto-preview grep:.<cr>
			" TODO: get something like this working:
			" vmap [unite]g :UniteWithCursorWord grep:.<cr>

		" current and recent
			" most recently used (mru) files
			nmap [unite]r :Unite              -buffer-name=recent file_mru<cr>
			nmap [unite]R :UniteWithBufferDir -buffer-name=recent file_mru<cr>
			nmap [unite][alt]r :Unite              -buffer-name=recent -auto-preview file_mru<cr>
			nmap [unite][alt]R :UniteWithBufferDir -buffer-name=recent -auto-preview file_mru<cr>

			" current buffers
			nmap [unite]b :Unite              -buffer-name=buffers buffer<cr>
			nmap [unite]B :UniteWithBufferDir -buffer-name=buffers buffer<cr>
			nmap [unite][alt]b :Unite              -buffer-name=buffers -auto-preview buffer<cr>
			nmap [unite][alt]B :UniteWithBufferDir -buffer-name=buffers -auto-preview buffer<cr>

			" buffer, tab, or files
			nmap [unite]a :Unite              -start-insert buffer tab file_mru directory_mru bookmark<cr>
			nmap [unite]A :UniteWithBufferDir -start-insert buffer tab file_mru directory_mru bookmark<cr>
			nmap [unite][alt]a :Unite              -start-insert -auto-preview buffer tab file_mru directory_mru bookmark<cr>
			nmap [unite][alt]A :UniteWithBufferDir -start-insert -auto-preview buffer tab file_mru directory_mru bookmark<cr>

		" current file
			" outline
			nmap [unite]o :Unite               -buffer-name=outline -no-split -auto-preview outline<cr>
			nmap [unite]O :UniteWithCursorWord -buffer-name=outline -no-split -auto-preview outline<cr>
			nmap [unite][alt]o :Unite               -buffer-name=outline -no-split -auto-preview -auto-preview outline<cr>
			nmap [unite][alt]O :UniteWithCursorWord -buffer-name=outline -no-split -auto-preview -auto-preview outline<cr>

			" line
			nmap [unite]l :Unite               -buffer-name=search -no-split -auto-preview -start-insert line<cr>
			nmap [unite]L :UniteWithCursorWord -buffer-name=search -no-split -auto-preview -start-insert line<cr>
			nmap [unite][alt]l :Unite               -buffer-name=search -no-split -auto-preview -start-insert -auto-preview line<cr>
			nmap [unite][alt]L :UniteWithCursorWord -buffer-name=search -no-split -auto-preview -start-insert -auto-preview line<cr>

			" changes
			nmap [unite]k :Unite               -buffer-name=search change<cr>
			nmap [unite]K :UniteWithCursorWord -buffer-name=search change<cr>
			nmap [unite][alt]k :Unite               -buffer-name=search -auto-preview change<cr>
			nmap [unite][alt]K :UniteWithCursorWord -buffer-name=search -auto-preview change<cr>

		" misc
			" do all the things
			nmap [unite]<cr> :Unite -buffer-name=omni -start-insert source<cr>
			nmap [unite][alt]<cr> :Unite -buffer-name=omni -start-insert -auto-preview source<cr>

			" yank stack
			nmap [unite]y :Unite -buffer-name=yank history/yank<cr>
			nmap [unite][alt]y :Unite -buffer-name=yank -auto-preview history/yank<cr>

			" command history
			nmap [unite]; :Unite -buffer-name=commands -default-action=execute history/command command<cr>
			nmap [unite][alt]; :Unite -buffer-name=commands -default-action=execute -auto-preview history/command command<cr>

			" repeat last entry
			nmap [unite]. :UniteResume<cr>
			nmap [unite][alt]. :UniteResume -auto-preview<cr>

	" NERDTree:
		" show hidden files
		let g:NERDTreeShowHidden = 1

		" always focus file pane (this doesn't seem to work)
		" let g:nerdtree_tabs_smart_startup_focus = 2

		" if no files were passed, open NERDTree on startup
		" autocmd StdinReadPre * let s:std_in=1
		" autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif

		" L-n => toggle NERDTreeTabs
		map <leader>n <plug>NERDTreeTabsToggle<cr>

	" Gundu:
		" L-U => toggle gundu menu [:GunduToggle]
		map <leader>U :GundoToggle<cr>

	" vim-surround:
		" |vs| => |vS|
		vmap s S

	" vim-airline:
		" powerline symbols
		let g:airline#extensions#tabline#enabled = 1
		let g:airline_powerline_fonts   = 1
		let g:airline_theme             = 'base16'
		let g:airline_enable_branch     = 1

		if !exists('g:airline_symbols')
			let g:airline_symbols = {}
		endif
		" let g:airline_symbols.space = "\ua0"

	" vim-autoformat:
		" format entire file
		nmap QQ :Autoformat<cr>

	" vim-easymotion:
		let g:EasyMotion_startofline = 0 " keep cursor colum when JK motion

		" prefix
		map <leader>f <plug>(easymotion-prefix)

		" vim-sneak
		nmap s <plug>(easymotion-s2)
		nmap S <plug>(easymotion-t2)

		map <Leader>l <Plug>(easymotion-lineforward)
		map <Leader>j <Plug>(easymotion-j)
		map <Leader>k <Plug>(easymotion-k)
		map <Leader>h <Plug>(easymotion-linebackward)

	" vim-tmux-navigator:
		" let the nav shortcuts work anywhere
		let g:tmux_navigator_no_mappings = 1

		map <silent> <c-h> :TmuxNavigateLeft<cr>
		map <silent> <c-l> :TmuxNavigateRight<cr>
		map <silent> <c-k> :TmuxNavigateUp<cr>
		map <silent> <c-j> :TmuxNavigateDown<cr>
		map <silent> <c-\> :TmuxNavigatePrevious<cr>

		map <silent> <m-h> :TmuxNavigateLeft<cr>
		map <silent> <m-l> :TmuxNavigateRight<cr>
		map <silent> <m-k> :TmuxNavigateUp<cr>
		map <silent> <m-j> :TmuxNavigateDown<cr>
		map <silent> <m-\> :TmuxNavigatePrevious<cr>

		imap <silent> <c-h> <esc>:TmuxNavigateLeft<cr>
		imap <silent> <c-l> <esc>:TmuxNavigateDown<cr>
		imap <silent> <c-k> <esc>:TmuxNavigateUp<cr>
		imap <silent> <c-j> <esc>:TmuxNavigateRight<cr>
		imap <silent> <c-\> <esc>:TmuxNavigatePrevious<cr>

		imap <silent> <m-h> <esc>:TmuxNavigateLeft<cr>
		imap <silent> <m-l> <esc>:TmuxNavigateDown<cr>
		imap <silent> <m-k> <esc>:TmuxNavigateUp<cr>
		imap <silent> <m-j> <esc>:TmuxNavigateRight<cr>
		imap <silent> <m-\> <esc>:TmuxNavigatePrevious<cr>

