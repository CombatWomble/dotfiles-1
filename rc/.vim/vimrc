""""""""""""""""
" NEOBUNDLE:
""""""""""""""""
	" Disable vi-compatibility
	set nocompatible

	if has ('vim_starting')
		set runtimepath+=~/.vim/bundle/neobundle.vim/
	endif

	call neobundle#begin(expand('~/.vim/bundle/'))

	" PLUGINS
		" Let NeoBundle manage NeoBundle
		NeoBundleFetch 'Shougo/neobundle.vim'

		NeoBundle 'Shougo/vimproc.vim', {
		\ 'build' : {
		\     'windows' : 'tools\\update-dll-mingw',
		\     'cygwin' : 'make -f make_cygwin.mak',
		\     'mac' : 'make -f make_mac.mak',
		\     'unix' : 'make -f make_unix.mak',
		\    },
		\ }

		" enhancements
			" let `.` repeat things like plugin mappings
			NeoBundle 'tpope/vim-repeat'
			" <tab>-complete in insert mode
			NeoBundle 'ervandew/supertab'
			" <tab>-complete in the search prompt
			NeoBundle 'SearchComplete'
			" let `/` and `?` use perl regex
			NeoBundle 'othree/eregex.vim'

		" navigation
			NeoBundle 'Lokaltog/vim-easymotion'

		" motions
			NeoBundle 'bkad/CamelCaseMotion'

		" UI
			NeoBundle 'bling/vim-airline'
			NeoBundle 'paranoida/vim-airlineish'
			NeoBundle 'chriskempson/base16-vim'
			" sexy scrolling, with easing and animation
			" NOTE: messes with mouse scrolling, which currently upsets me
			" NeoBundle 'joeytwiddle/sexy_scroller.vim'

		" languages
			" autoformat support for multiple
			NeoBundle 'Chiel92/vim-autoformat'
			" js
			NeoBundle 'jelera/vim-javascript-syntax'
			" hbs
			NeoBundle 'mustache/vim-mustache-handlebars'
			" jsdoc
			NeoBundle 'heavenshell/vim-jsdoc'
			" i3 config
			NeoBundle 'PotatoesMaster/i3-vim-syntax'

		" integration
			" git
			NeoBundle 'tpope/vim-fugitive'
			" ag, the silver searcher
			NeoBundle 'rking/ag.vim'
			" LaTeX
			NeoBundle 'LaTeX-Box-Team/LaTeX-Box'

		" unite
			NeoBundle 'Shougo/unite.vim'
			NeoBundle 'Shougo/neomru.vim'
			NeoBundle 'Shougo/unite-outline'
			NeoBundle 'thinca/vim-unite-history'

		" utils
			" sensible default settings
			NeoBundle 'tpope/vim-sensible'
			" auto-detuct indent settings
			NeoBundle 'tpope/vim-sleuth'
			NeoBundle 'tpope/vim-surround'
			" comment mappings
			NeoBundle 'tpope/vim-commentary'
			" settings toggles and symmetrical before/after mappings
			NeoBundle 'tpope/vim-unimpaired'
			NeoBundle 'scrooloose/nerdtree'
			NeoBundle 'jistr/vim-nerdtree-tabs'
			" visualized undo tree
			NeoBundle 'sjl/gundo.vim'
			" better multiple-cursor functionality
			NeoBundle 'terryma/vim-multiple-cursors'
			" diff two selections
			NeoBundle 'AndrewRadev/linediff.vim'
			NeoBundle 'scrooloose/syntastic'
			NeoBundle 'thinca/vim-qfreplace'
			" show trailing whitespace, and provide a command to clean it
			NeoBundle 'ntpeters/vim-better-whitespace'

		" external
			NeoBundle 'christoomey/vim-tmux-navigator'
			NeoBundle 'edkolev/tmuxline.vim'
			NeoBundle 'edkolev/promptline.vim'
	" /PLUGINS

	call neobundle#end()

	" Prompt to install any newly added bundles
	NeoBundleCheck


""""""""""""""""
" SETTINGS:
""""""""""""""""
	" line numbers
	set number
	set smartcase
	set ignorecase
	set hlsearch
	set cursorline

	" tabs!
	set tabstop=4
	set shiftwidth=4

	" turn off auto-textwrap (vim-sensible turns it on)
	set textwidth=0

	" spell checking (toggled with `cos`)
	" set spell

	" simple mouse support
	set mouse=a

	" paste without comments messing everything up
	set pastetoggle=<f4>

	" Let arrow keys pass \n
	set whichwrap=b,s,<,>,[,]

	" folding
	set foldmethod=indent
	set foldlevelstart=128
	set foldcolumn=2
	augroup rcFolds
		" support both indent and manual folding
		au BufReadPre * setlocal foldmethod=indent
		au BufWinEnter * if &fdm == 'indent' | setlocal foldmethod=manual | endif
	augroup END

	" more natural splits
	set splitbelow
	set splitright

	" ignore in searches
	set wildignore+=node_modules/**


""""""""""""""""
" THEME:
""""""""""""""""
	syntax enable
	set t_Co=256
	set background=dark
	" set background=light

	" access colors present in 256 colorspace
	let base16colorspace=256
	colorscheme base16-default
	" colorscheme base16-google


""""""""""""""""
" MAPPINGS:
""""""""""""""""
	" make prefixes
	" TODO: automate the "mode" creation
	function! s:makePrefix(name, key, ...)
		" accept `mode` number as an optional third argument
		let l:mode = (a:0 >= 1) ? a:1 : 0

		let l:doOverride = (a:0 == 0 || a:1 != 0)

		let l:prefixLong = '[' . a:name . ':' . l:mode . ']'
		execute 'map ' . l:prefixLong . ' <nop>'
		if l:doOverride == 1
			execute 'map ' . a:key . ' ' . l:prefixLong
		endif

		if l:mode == 0
			let l:prefix = '[' . a:name . ']'
			execute 'map ' . l:prefix . ' <nop>'
			execute 'map ' . l:prefixLong . ' ' . l:prefix
		endif

		if l:doOverride == 0
			execute 'map ' . l:prefix . ' ' . a:key
		endif
	endfunction

	" take me to your leader
	" for single letter mappings
	let mapleader=","
	call s:makePrefix('leader', '<leader>')
	call s:makePrefix('leader', '[leader]<leader>', 1)

	" localleader
	" for filetype-specific mappings
	let maplocalleader="-"
	call s:makePrefix('localleader', '<localleader>')
	call s:makePrefix('localleader', '[localleader]<localleader>', 1)

	" prefix
	" for grouped/corded mappings
	call s:makePrefix('prefix', '<space>')
	call s:makePrefix('prefix', '[prefix]<space>', 1)

	" expose the native mappings I've stolen
		" TODO: abstract this a bit, perhaps a function that takes an array of keys to fix
		" TODO: independent of above, maybe I should fix all keys, instead of maintaining a list
		noremap [leader:1]Y Y
		noremap [leader:1]s s
		noremap [leader:1]S S
		noremap [leader:1]U U
		noremap [leader:1]Q Q
		noremap [leader:1]< <
		noremap [leader:1]> >
		noremap [leader:1]; ;
		noremap [leader:1], ,
		noremap [leader:1]- -
		noremap [leader:1]<space> <space>

	" fix Y
	map Y y$

	" shift is for sucks? (avoids :W style typos, or so I'm told)
	map ; :

	" L-s => save [:update]
	map <leader>s :update<cr>
	" L-S => force save [:write]
	map <leader>S :write<cr>

	" L-w => quit [:quit]
	map <leader>w :quit<cr>
	" L-W => force quit [:quit!]
	map <leader>W :quit!<cr>

	" L-x => save and quit [:wq]
	map <leader>x :wq<cr>

	" U => redo [:redo]
	map U :redo<cr>

	" L-r => reload file [:edit]
	map <leader>r :edit<cr>
	map <leader>R :edit!<cr>

	" insert/append
		" tab
		noremap <leader>it i<tab>
		noremap <leader>i<tab> i<tab>
		noremap <leader>at a<tab>
		noremap <leader>a<tab> a<tab>

	" [buffers]
		" prefix
		call s:makePrefix('buffers', '[prefix]b')

		" split buffer [h, j, k, l]
		map [buffers]h :leftabove vnew<cr>
		map [buffers]l :rightbelow vnew<cr>
		map [buffers]j :rightbelow new<cr>
		map [buffers]k :leftabove new<cr>

	" [windows]
		" prefix
		call s:makePrefix('windows', '[prefix]w')

		" split window [h, j, k, l]
		map [windows]h :topleft vnew<cr>
		map [windows]l :botright vnew<cr>
		map [windows]j :botright new<cr>
		map [windows]k :topleft new<cr>

		" move window [H, J, K, L]
		" NOTE: this is not expected, but all vim can natively do
		map [windows]H <c-w>H
		map [windows]L <c-w>L
		map [windows]J <c-w>J
		map [windows]K <c-w>K

		" move window to a new tab
		map [windows]t <c-w>T

		" close all other windows
		map [windows]o <c-w>O

	" [tabs]
		" prefix
		call s:makePrefix('tabs', '[prefix]t')
		call s:makePrefix('tabs', '[tabs]t', 1)

		" new, at [n:+1]
		map [tabs:0]n :<c-u>exe v:count."tabnew"<cr>
		" duplicate
		map [tabs:0]d :tabnew %<cr>
		" close
		map [tabs:0]w :tabclose<cr>
		map [tabs:0]W :tabclose!<cr>
		" close others
		map [tabs:0]o :tabonly<cr>
		map [tabs:0]O :tabonly!<cr>

		" NOTE: technically [tabs]g and [tabs]l are the same,
		" though semantically the former is for absolute navigation and the latter for relative
		" goto [n:+1]
		map [tabs:0]g :<c-u>exe (v:count == 0) ? "tabnext" : "tabnext ".v:count1<cr>
		" next [n:+1]
		map [tabs:0]l :<c-u>exe (v:count == 0) ? "tabnext" : "tabnext ".v:count1<cr>
		" previous [n::1]
		map [tabs:0]h :<c-u>exe (v:count == 0) ? "tabprevious" : "tabprevious ".v:count1<cr>
		" first
		map [tabs:0]f :tabfirst<cr>
		" last
		map [tabs:0]F :tablast<cr>

		" move [n:1] left
		map [tabs:1]h :<c-u>exe "tabmove -".v:count1<cr>
		" move [n:1] right
		map [tabs:1]l :<c-u>exe "tabmove +".v:count1<cr>
		" move to [n:end]
		map [tabs:1]m :<c-u>exe "tabmove ".v:count<cr>

	" [folds]
		" prefix
		call s:makePrefix('folds', '[prefix]z')

		nnoremap <silent> [folds]<space> @=(foldlevel('.')?'za':"\<space>")<cr>
		vnoremap [folds]<space> zf
		nmap [folds]` :set foldlevel=0<cr>
		nmap [folds]1 :set foldlevel=1<cr>
		nmap [folds]2 :set foldlevel=2<cr>
		nmap [folds]3 :set foldlevel=3<cr>
		nmap [folds]4 :set foldlevel=4<cr>
		nmap [folds]5 :set foldlevel=5<cr>
		nmap [folds]6 :set foldlevel=6<cr>
		nmap [folds]7 :set foldlevel=7<cr>
		nmap [folds]8 :set foldlevel=8<cr>
		nmap [folds]9 :set foldlevel=9<cr>
		nmap [folds]0 :set foldlevel=128<cr>
		nmap [folds]z :call ToggleFold()<cr>

		let b:foldlevel=&l:foldlevel
		function! ToggleFold()
			if &l:foldmethod == 'indent'
				set foldmethod=manual
			else
				set foldmethod=indent
			endif
			" if &l:foldenable
			" 	let b:foldlevel=&l:foldlevel
			" 	set nofoldenable
			" else
			" 	set foldenable
			" 	set foldlevel = b:foldlevel
			" endif
		endfunction

	" searching
		" clear highlighted search
		nmap [leader:1]/ :nohlsearch<cr>
		" search for selected word
		vmap <leader>/ y/<c-r>"<cr>
		vmap <leader>? y?<c-r>"<cr>

	" visual shifting (does not exit Visual mode)
	vnoremap < <gv
	vnoremap > >gv

	" use Q for formatting, not Ex mode
	map Q gq

	" set a break in undo, so CTRL-U in insert mode is less destructive
	map <c-u> <c-g>u<c-u>

	" switch to alternate file
	map <leader>b <c-^>

	" easier system clipboard
	map <leader>y "+y
	map <leader>Y "+Y
	map <leader>p "+p
	map <leader>P "+P

	" grade-A prankster
	noremap <up> <left>
	noremap <down> <up>
	noremap <left> <right>
	noremap <right> <down>

	" CONSOLE
		" :W => write with sudo
		command! W :execute ':silent w !sudo tee % > /dev/null' | :edit!

		" reload vimrc config
		command! Reload source ~/.vim/vimrc

		" change Working Directory to that of the current file
		command! CWD lcd %:p:h

		" diff unsaved changes
		if !exists(":DiffChanges")
			command DiffChanges vert new | set bt=nofile | r ++edit # | 0d_ | diffthis | wincmd p | diffthis
		endif


""""""""""""""""
" MISC:
""""""""""""""""
	if has("autocmd")
		filetype plugin on

		augroup rcMain
			au!

			" Reload vimrc when edited (using :reload, defined above)
			autocmd! BufWritePost vimrc source ~/.vim/vimrc

			" Preserve cursor position
			autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif

			" Remove trailing whitespaces and \^M chars
			" NOTE: removing in favor of vim-better-whitespace, for more control/knowledge
			" autocmd FileType c,cpp,java,php,js,python,twig,xml,yml autocmd BufWritePre <buffer> :call setline(1, map(getline(1, '$'), 'substitute(v:val, "\\s\\+$", "", "")'))

			" turn on spell check in certain files, and move cursor to beginning of gitcommits
			autocmd BufRead,BufNewFile *.md setlocal spell | set complete+=kspell
			autocmd FileType gitcommit setlocal spell | set complete+=kspell | call cursor(1, 1)

			" syntax highlighting
			autocmd BufNewFile,BufReadPost *.md set filetype=markdown

			" default to shell script syntax
			autocmd BufNewFile,BufRead * if &syntax == '' | set syntax=sh | endif
			autocmd BufNewFile,BufRead * if &filetype == '' | set filetype=sh | endif
		augroup END
	endif


""""""""""""""""
" PLUGINS:
""""""""""""""""
	" Unite:
		let g:unite_source_history_yank_enable = 1

		" ack >> grep
		if executable('ack')
			let g:unite_source_grep_command = 'ack'
			let g:unite_source_grep_default_opts = '-i --no-heading --no-color -k -H'
			let g:unite_source_grep_recursive_opt = ''
		endif

		" ag > ack
		if executable('ag')
			let g:unite_source_grep_command = 'ag'
			let g:unite_source_grep_default_opts = '--nogroup --nocolor --column --hidden'
			let g:unite_source_grep_recursive_opt = ''
			let g:unite_source_rec_async_command = 'ag' .
				\ ' --follow' .
				\ ' --nocolor' .
				\ ' --nogroup' .
				\ ' --hidden' .
				\ ' --ignore ".git"' .
				\ ' -g ""'
		endif

		call unite#custom#profile('default', 'context', {
		\   'winheight': 24,
		\ })

		call unite#filters#matcher_default#use(['matcher_fuzzy'])
		call unite#custom#source('buffer,file,file_rec,file_rec/async', 'sorters', ['sorter_length', 'sorter_rank'])
		call unite#custom#source('file_rec/async', 'ignore_globs', split(&wildignore, ','))
		call unite#custom#source('file_rec/async', 'converters', [])
		call unite#custom#source('file_rec/async', 'max_candidates', 24)
		" prettier output
		call unite#custom#source('buffer', 'converters', ['converter_file_directory'])

		" in-buffer settings
		function! s:uniteSettings()
			let b:SuperTabDisabled = 1

			" vertical selecting (`j` and `k` is default in normal mode)
			map <buffer> <c-j> <plug>(unite_select_next_line)
			imap <buffer> <c-j> <plug>(unite_select_next_line)
			map <buffer> <c-k> <plug>(unite_select_previous_line)
			imap <buffer> <c-k> <plug>(unite_select_previous_line)

			" action menu (`a` is default in normal mode)
			map <buffer> <c-a> <plug>(unite_choose_action)
			imap <buffer> <c-a> <plug>(unite_choose_action)
			" TODO: get something like this working: (may depend on https://github.com/Shougo/unite.vim/issues/280)
			vmap <buffer> a <plug>(unite_choose_action)

			" open in vertical split
			map <buffer><expr> - unite#do_action('split')
			map <buffer><expr> <c--> unite#do_action('split')
			imap <buffer><expr> <c--> unite#do_action('split')
			" open in horizontal split
			map <buffer><expr> s unite#do_action('vsplit')
			map <buffer><expr> <c-s> unite#do_action('vsplit')
			imap <buffer><expr> <c-s> unite#do_action('vsplit')
			" open in new tab (`t` is default in normal mode)
			map <buffer><expr> <c-t> unite#do_action('tabopen')
			imap <buffer><expr> <c-t> unite#do_action('tabopen')

			" toggle auto preview
			nmap <buffer> <c-p> <plug>(unite_toggle_auto_preview)

			" exit
			nmap <buffer> <esc> <plug>(unite_exit)

			let unite = unite#get_current_unite()
			if unite.profile_name ==# 'search'
				nmap <silent><buffer><expr> r unite#do_action('replace')
			else
				nmap <silent><buffer><expr> r unite#do_action('rename')
			endif
		endfunction
		autocmd FileType unite call s:uniteSettings()

		" prefix
		call s:makePrefix('unite', '[prefix]u')
		call s:makePrefix('unite', '[unite]u', 1)

		" open files
			" flat
			nmap [unite:0]f :Unite              -buffer-name=files -start-insert file directory file/new directory/new<cr>
			nmap [unite:0]F :UniteWithBufferDir -buffer-name=files -start-insert file directory file/new directory/new<cr>
			nmap [unite:1]f :Unite              -buffer-name=files -start-insert -auto-preview file directory file/new directory/new<cr>
			nmap [unite:1]F :UniteWithBufferDir -buffer-name=files -start-insert -auto-preview file directory file/new directory/new<cr>

			" recursive
			nmap [unite:0]p :Unite              -buffer-name=files -start-insert file_rec/async:!<cr>
			nmap [unite:0]P :UniteWithBufferDir -buffer-name=files -start-insert file_rec/async:!<cr>
			nmap [unite:1]p :Unite              -buffer-name=files -start-insert -auto-preview file_rec/async:!<cr>
			nmap [unite:1]P :UniteWithBufferDir -buffer-name=files -start-insert -auto-preview file_rec/async:!<cr>

		" search files
			nmap [unite:0]g :Unite              grep:.<cr>
			nmap [unite:0]G :UniteWithBufferDir grep:.<cr>
			nmap [unite:1]g :Unite              -auto-preview grep:.<cr>
			nmap [unite:1]G :UniteWithBufferDir -auto-preview grep:.<cr>
			" TODO: get something like this working:
			" vmap [unite:0]g :UniteWithCursorWord grep:.<cr>

		" current and recent
			" most recently used (mru) files
			nmap [unite:0]r :Unite              -buffer-name=recent file_mru<cr>
			nmap [unite:0]R :UniteWithBufferDir -buffer-name=recent file_mru<cr>
			nmap [unite:1]r :Unite              -buffer-name=recent -auto-preview file_mru<cr>
			nmap [unite:1]R :UniteWithBufferDir -buffer-name=recent -auto-preview file_mru<cr>

			" current buffers
			nmap [unite:0]b :Unite              -buffer-name=buffers buffer<cr>
			nmap [unite:0]B :UniteWithBufferDir -buffer-name=buffers buffer<cr>
			nmap [unite:1]b :Unite              -buffer-name=buffers -auto-preview buffer<cr>
			nmap [unite:1]B :UniteWithBufferDir -buffer-name=buffers -auto-preview buffer<cr>

			" buffer, tab, or files
			nmap [unite:0]a :Unite              -start-insert buffer tab file_mru directory_mru bookmark<cr>
			nmap [unite:0]A :UniteWithBufferDir -start-insert buffer tab file_mru directory_mru bookmark<cr>
			nmap [unite:1]a :Unite              -start-insert -auto-preview buffer tab file_mru directory_mru bookmark<cr>
			nmap [unite:1]A :UniteWithBufferDir -start-insert -auto-preview buffer tab file_mru directory_mru bookmark<cr>

		" current file
			" outline
			nmap [unite:0]o :Unite               -buffer-name=outline -no-split -auto-preview outline<cr>
			nmap [unite:0]O :UniteWithCursorWord -buffer-name=outline -no-split -auto-preview outline<cr>
			nmap [unite:1]o :Unite               -buffer-name=outline -no-split -auto-preview -auto-preview outline<cr>
			nmap [unite:1]O :UniteWithCursorWord -buffer-name=outline -no-split -auto-preview -auto-preview outline<cr>

			" line
			nmap [unite:0]l :Unite               -buffer-name=search -no-split -auto-preview -start-insert line<cr>
			nmap [unite:0]L :UniteWithCursorWord -buffer-name=search -no-split -auto-preview -start-insert line<cr>
			nmap [unite:1]l :Unite               -buffer-name=search -no-split -auto-preview -start-insert -auto-preview line<cr>
			nmap [unite:1]L :UniteWithCursorWord -buffer-name=search -no-split -auto-preview -start-insert -auto-preview line<cr>

			" changes
			nmap [unite:0]k :Unite               -buffer-name=search change<cr>
			nmap [unite:0]K :UniteWithCursorWord -buffer-name=search change<cr>
			nmap [unite:1]k :Unite               -buffer-name=search -auto-preview change<cr>
			nmap [unite:1]K :UniteWithCursorWord -buffer-name=search -auto-preview change<cr>

		" misc
			" do all the things
			nmap [unite:0]<cr> :Unite -buffer-name=omni -start-insert source<cr>
			nmap [unite:1]<cr> :Unite -buffer-name=omni -start-insert -auto-preview source<cr>

			" yank stack
			nmap [unite:0]y :Unite -buffer-name=yank history/yank<cr>
			nmap [unite:1]y :Unite -buffer-name=yank -auto-preview history/yank<cr>

			" command history
			nmap [unite:0]; :Unite -buffer-name=commands -default-action=execute history/command command<cr>
			nmap [unite:1]; :Unite -buffer-name=commands -default-action=execute -auto-preview history/command command<cr>

			" repeat last entry
			nmap [unite:0]. :UniteResume<cr>
			nmap [unite:1]. :UniteResume -auto-preview<cr>

	" NERDTree:
		" show hidden files
		let g:NERDTreeShowHidden = 1

		" always focus file pane (this doesn't seem to work)
		" let g:nerdtree_tabs_smart_startup_focus = 2

		" if no files were passed, open NERDTree on startup
		" autocmd StdinReadPre * let s:std_in=1
		" autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif

		" L-n => toggle NERDTreeTabs
		map <leader>N <plug>NERDTreeTabsToggle<cr>

	" Gundu:
		" L-U => toggle gundu menu [:GunduToggle]
		map <leader>U :GundoToggle<cr>

	" vim-surround:
		" |vs| => |vS|
		vmap s S

	" vim-airline:
		" powerline symbols
		let g:airline#extensions#tabline#enabled = 1
		let g:airline_powerline_fonts   = 1
		let g:airline_enable_branch     = 1
		let g:airline_theme = 'airlineish'

		" this makes the base16 theme work
		let g:airline#themes#base16#constant = 1

		" if !exists('g:airline_symbols')
		" 	let g:airline_symbols = {}
		" endif
		" let g:airline_symbols.space = "\ua0"

	" vim-autoformat:
		" format entire file
		nmap QQ :Autoformat<cr>

	" vim-easymotion:
		let g:EasyMotion_startofline = 0 " keep cursor colum when JK motion

		" prefix
		map <leader>f <plug>(easymotion-prefix)

		" vim-sneak
		nmap s <plug>(easymotion-s2)
		nmap S <plug>(easymotion-t2)

		map <leader>l <plug>(easymotion-lineforward)
		map <leader>j <plug>(easymotion-j)
		map <leader>k <plug>(easymotion-k)
		map <leader>h <plug>(easymotion-linebackward)

	" vim-tmux-navigator:
		" use my own mappings, <meta> instead of <control>
		let g:tmux_navigator_no_mappings = 1

		map <silent> <m-h> :TmuxNavigateLeft<cr>
		map <silent> <m-l> :TmuxNavigateRight<cr>
		map <silent> <m-k> :TmuxNavigateUp<cr>
		map <silent> <m-j> :TmuxNavigateDown<cr>
		map <silent> <m-\> :TmuxNavigatePrevious<cr>

		map <silent> <c-h> :TmuxNavigateLeft<cr>
		map <silent> <c-l> :TmuxNavigateRight<cr>
		map <silent> <c-k> :TmuxNavigateUp<cr>
		map <silent> <c-j> :TmuxNavigateDown<cr>
		map <silent> <c-\> :TmuxNavigatePrevious<cr>

		imap <silent> <m-h> <esc>:TmuxNavigateLeft<cr>
		imap <silent> <m-l> <esc>:TmuxNavigateDown<cr>
		imap <silent> <m-k> <esc>:TmuxNavigateUp<cr>
		imap <silent> <m-j> <esc>:TmuxNavigateRight<cr>
		imap <silent> <m-\> <esc>:TmuxNavigatePrevious<cr>

		imap <silent> <c-h> <esc>:TmuxNavigateLeft<cr>
		imap <silent> <c-l> <esc>:TmuxNavigateDown<cr>
		imap <silent> <c-k> <esc>:TmuxNavigateUp<cr>
		imap <silent> <c-j> <esc>:TmuxNavigateRight<cr>
		imap <silent> <c-\> <esc>:TmuxNavigatePrevious<cr>

	" vim-jsdoc
		let g:jsdoc_default_mapping = 0

		autocmd FileType javascript
			\ nmap <silent> <localleader>d <plug>(jsdoc)

	" eregex
		" disable the default `/` and `?` override
		let g:eregex_default_enable = 0

		nnoremap <leader>/ :M/
		nnoremap <leader>? :M?

	" CamelCaseMotion
		call s:makePrefix('camel', '[prefix]c')

		map <silent> [camel]w <Plug>CamelCaseMotion_w
		map <silent> [camel]b <Plug>CamelCaseMotion_b
		map <silent> [camel]e <Plug>CamelCaseMotion_e

		omap <silent> [camel]iw <Plug>CamelCaseMotion_iw
		xmap <silent> [camel]iw <Plug>CamelCaseMotion_iw
		omap <silent> [camel]ib <Plug>CamelCaseMotion_ib
		xmap <silent> [camel]ib <Plug>CamelCaseMotion_ib
		omap <silent> [camel]ie <Plug>CamelCaseMotion_ie
		xmap <silent> [camel]ie <Plug>CamelCaseMotion_ie

	" vim-better-whitespace
		map coW :ToggleWhitespace<cr>
		map coS :ToggleStripWhitespaceOnSave<cr>
